{
  "name": "WiseBot - Knowledge Gateway",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "wisebot/knowledge",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-trigger",
      "name": "Knowledge Gateway Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "wisebot-knowledge-gateway"
    },
    {
      "parameters": {
        "content": "## WiseBot Knowledge Gateway\n\n**Purpose:** Unified retrieval endpoint for all WiseBot knowledge queries.\n\n**Endpoint:** POST /webhook/wisebot/knowledge\n\n**Request Schema:**\n```json\n{\n  \"query\": \"string (required)\",\n  \"agent_id\": \"string (optional)\",\n  \"top_k\": 10,\n  \"filters\": {\n    \"doc_type\": \"text|audio|image|tabular\",\n    \"start_date\": \"ISO date\",\n    \"end_date\": \"ISO date\"\n  },\n  \"include_answer\": false,\n  \"context_only\": false\n}\n```\n\n**Response Schema:**\n```json\n{\n  \"matched_chunks\": [...],\n  \"answer\": \"string (if requested)\",\n  \"context_prompt\": \"string (if requested)\"\n}\n```",
        "height": 520,
        "width": 400
      },
      "id": "sticky-intro",
      "name": "Sticky Note - Introduction",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [40, 20]
    },
    {
      "parameters": {
        "jsCode": "// Validate and parse incoming request\nconst body = $input.first().json.body || $input.first().json;\n\n// Required field\nif (!body.query || typeof body.query !== 'string' || body.query.trim().length === 0) {\n  return [{\n    json: {\n      error: true,\n      message: 'Missing required field: query',\n      status: 400\n    }\n  }];\n}\n\n// Parse optional parameters with defaults\nconst request = {\n  query: body.query.trim(),\n  agentId: body.agent_id || null,\n  topK: Math.min(Math.max(parseInt(body.top_k) || 10, 1), 50), // 1-50\n  filters: {\n    docType: body.filters?.doc_type || null,\n    startDate: body.filters?.start_date || null,\n    endDate: body.filters?.end_date || null\n  },\n  includeAnswer: body.include_answer === true,\n  contextOnly: body.context_only === true,\n  requestId: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n  receivedAt: new Date().toISOString()\n};\n\n// Validate date formats if provided\nif (request.filters.startDate && isNaN(Date.parse(request.filters.startDate))) {\n  return [{\n    json: {\n      error: true,\n      message: 'Invalid start_date format. Use ISO 8601.',\n      status: 400\n    }\n  }];\n}\n\nif (request.filters.endDate && isNaN(Date.parse(request.filters.endDate))) {\n  return [{\n    json: {\n      error: true,\n      message: 'Invalid end_date format. Use ISO 8601.',\n      status: 400\n    }\n  }];\n}\n\nreturn [{ json: request }];"
      },
      "id": "validate-request",
      "name": "Validate Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "is-error",
              "leftValue": "={{$json.error}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-validation-error",
      "name": "Validation Error?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"{{$json.message}}\"\n}",
        "options": {
          "responseCode": "={{$json.status}}"
        }
      },
      "id": "respond-error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [900, 200]
    },
    {
      "parameters": {
        "resource": "embedding",
        "model": "={{ $env.WISEBOT_EMBEDDING_MODEL || 'text-embedding-3-small' }}",
        "text": "={{$json.query}}",
        "options": {}
      },
      "id": "embed-query",
      "name": "Embed Query",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [900, 400],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_ID",
          "name": "OpenAI"
        }
      }
    },
    {
      "parameters": {
        "content": "## Query Embedding\n\n**Model:** Same as ingestion (configurable)\n**Provider:** OpenAI (configurable)\n\n**Important:** Query embedding model MUST match document embedding model for accurate similarity search.",
        "height": 160,
        "width": 280
      },
      "id": "sticky-embed",
      "name": "Sticky Note - Embed",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [900, 540]
    },
    {
      "parameters": {
        "jsCode": "// Prepare embedding for Supabase query\nconst embeddingResult = $input.first().json;\nconst request = $('Validate Request').first().json;\n\n// Extract embedding array\nconst embedding = embeddingResult.data?.[0]?.embedding || embeddingResult.embedding;\n\nif (!embedding || !Array.isArray(embedding)) {\n  throw new Error('Failed to generate query embedding');\n}\n\n// Format embedding as PostgreSQL vector\nconst embeddingVector = `[${embedding.join(',')}]`;\n\nreturn [{\n  json: {\n    ...request,\n    queryEmbedding: embeddingVector\n  }\n}];"
      },
      "id": "prepare-search",
      "name": "Prepare Search",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.SUPABASE_URL}}/rest/v1/rpc/search_similar_chunks",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query_embedding\": \"{{$json.queryEmbedding}}\",\n  \"match_count\": {{$json.topK}},\n  \"filter_doc_type\": {{$json.filters.docType ? '\"' + $json.filters.docType + '\"' : 'null'}},\n  \"filter_start_date\": {{$json.filters.startDate ? '\"' + $json.filters.startDate + '\"' : 'null'}},\n  \"filter_end_date\": {{$json.filters.endDate ? '\"' + $json.filters.endDate + '\"' : 'null'}}\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "vector-search",
      "name": "Vector Similarity Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1340, 400],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "content": "## Vector Search\n\n**Function:** search_similar_chunks\n**Algorithm:** Cosine similarity\n**Index:** IVFFlat (lists=100)\n\n**Filters Applied:**\n- Document type (optional)\n- Date range (optional)\n\n**Returns:** top_k most similar chunks with metadata",
        "height": 220,
        "width": 280
      },
      "id": "sticky-search",
      "name": "Sticky Note - Search",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1340, 140]
    },
    {
      "parameters": {
        "jsCode": "// Process search results\nconst searchResults = $input.first().json;\nconst request = $('Validate Request').first().json;\n\n// Handle empty results\nif (!searchResults || !Array.isArray(searchResults)) {\n  return [{\n    json: {\n      request,\n      matchedChunks: [],\n      isEmpty: true\n    }\n  }];\n}\n\n// Format matched chunks\nconst matchedChunks = searchResults.map(result => ({\n  chunkId: result.chunk_id,\n  documentId: result.document_id,\n  text: result.chunk_text,\n  chunkIndex: result.chunk_index,\n  similarity: parseFloat(result.similarity?.toFixed(4) || 0),\n  metadata: {\n    fileName: result.file_name,\n    mimeType: result.mime_type,\n    docType: result.doc_type,\n    uploaderEmail: result.uploader_email,\n    sourceSubject: result.source_subject,\n    documentCreatedAt: result.document_created_at\n  }\n}));\n\nreturn [{\n  json: {\n    request,\n    matchedChunks,\n    isEmpty: matchedChunks.length === 0\n  }\n}];"
      },
      "id": "process-results",
      "name": "Process Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "include-answer",
              "leftValue": "={{$json.request.includeAnswer}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "need-answer",
      "name": "Generate Answer?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1780, 400]
    },
    {
      "parameters": {
        "jsCode": "// Build context prompt for LLM\nconst data = $input.first().json;\nconst chunks = data.matchedChunks;\nconst query = data.request.query;\n\n// Build context from chunks\nlet context = '';\nfor (const chunk of chunks) {\n  context += `\\n---\\nSource: ${chunk.metadata.fileName} (${chunk.metadata.docType})\\n`;\n  context += `Relevance: ${(chunk.similarity * 100).toFixed(1)}%\\n`;\n  context += `Content:\\n${chunk.text}\\n`;\n}\n\n// Build the prompt\nconst systemPrompt = `You are a helpful assistant with access to a knowledge base. Answer questions based ONLY on the provided context. If the context doesn't contain enough information to answer, say so clearly.`;\n\nconst userPrompt = `Context from knowledge base:\\n${context}\\n\\n---\\n\\nQuestion: ${query}\\n\\nProvide a clear, concise answer based on the context above.`;\n\nreturn [{\n  json: {\n    ...data,\n    systemPrompt,\n    userPrompt,\n    contextPrompt: `${systemPrompt}\\n\\n${userPrompt}`\n  }\n}];"
      },
      "id": "build-context-prompt",
      "name": "Build Context Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "claude-sonnet-4-20250514",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "={{$json.systemPrompt}}"
            },
            {
              "role": "user",
              "content": "={{$json.userPrompt}}"
            }
          ]
        },
        "options": {
          "maxTokens": 1000,
          "temperature": 0.3
        }
      },
      "id": "generate-answer",
      "name": "Generate Answer (Anthropic)",
      "type": "@n8n/n8n-nodes-langchain.anthropic",
      "typeVersion": 1,
      "position": [2220, 300],
      "credentials": {
        "anthropicApi": {
          "id": "ANTHROPIC_CREDENTIAL_ID",
          "name": "Anthropic"
        }
      }
    },
    {
      "parameters": {
        "content": "## Answer Generation (Optional)\n\n**Provider:** Anthropic Claude\n**Model:** claude-sonnet-4-20250514\n**Temperature:** 0.3 (factual)\n\n**Behavior:**\n- Only uses provided context\n- Acknowledges when info is insufficient\n- Concise, direct answers",
        "height": 200,
        "width": 280
      },
      "id": "sticky-answer",
      "name": "Sticky Note - Answer",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [2220, 60]
    },
    {
      "parameters": {
        "jsCode": "// Combine results with generated answer\nconst answerResult = $input.first().json;\nconst prevData = $('Build Context Prompt').first().json;\n\nconst answer = answerResult.content?.[0]?.text || \n               answerResult.choices?.[0]?.message?.content || \n               answerResult.content || \n               'Unable to generate answer';\n\nreturn [{\n  json: {\n    matchedChunks: prevData.matchedChunks,\n    answer,\n    contextPrompt: prevData.request.contextOnly ? prevData.contextPrompt : null,\n    query: prevData.request.query,\n    requestId: prevData.request.requestId\n  }\n}];"
      },
      "id": "format-with-answer",
      "name": "Format with Answer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2440, 300]
    },
    {
      "parameters": {
        "jsCode": "// Format response without answer\nconst data = $input.first().json;\n\n// Build context prompt if requested\nlet contextPrompt = null;\nif (data.request.contextOnly) {\n  let context = '';\n  for (const chunk of data.matchedChunks) {\n    context += `\\n---\\nSource: ${chunk.metadata.fileName}\\n${chunk.text}\\n`;\n  }\n  contextPrompt = `Use the following context to answer questions:\\n${context}\\n\\nQuestion: ${data.request.query}`;\n}\n\nreturn [{\n  json: {\n    matchedChunks: data.matchedChunks,\n    answer: null,\n    contextPrompt,\n    query: data.request.query,\n    requestId: data.request.requestId\n  }\n}];"
      },
      "id": "format-without-answer",
      "name": "Format without Answer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 500]
    },
    {
      "parameters": {},
      "id": "merge-responses",
      "name": "Merge Responses",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [2660, 400]
    },
    {
      "parameters": {
        "jsCode": "// Build final response\nconst data = $input.first().json;\n\nconst response = {\n  success: true,\n  request_id: data.requestId,\n  query: data.query,\n  matched_chunks: data.matchedChunks.map(chunk => ({\n    chunk_id: chunk.chunkId,\n    document_id: chunk.documentId,\n    text: chunk.text,\n    similarity_score: chunk.similarity,\n    metadata: {\n      file_name: chunk.metadata.fileName,\n      mime_type: chunk.metadata.mimeType,\n      doc_type: chunk.metadata.docType,\n      uploader_email: chunk.metadata.uploaderEmail,\n      source_subject: chunk.metadata.sourceSubject,\n      created_at: chunk.metadata.documentCreatedAt\n    }\n  })),\n  result_count: data.matchedChunks.length\n};\n\n// Add optional fields\nif (data.answer) {\n  response.answer = data.answer;\n}\n\nif (data.contextPrompt) {\n  response.context_prompt = data.contextPrompt;\n}\n\nreturn [{ json: response }];"
      },
      "id": "build-response",
      "name": "Build Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2880, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{JSON.stringify($json)}}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "X-Request-Id",
                "value": "={{$json.request_id}}"
              }
            ]
          }
        }
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3100, 400]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "ingestion_logs",
        "columns": "workflow_execution_id,step_name,status,success,metadata",
        "values": "='{{$execution.id}}','knowledge_gateway_query','completed',true,='{{JSON.stringify({query: $json.query, result_count: $json.result_count, request_id: $json.request_id})}}'",
        "options": {}
      },
      "id": "log-query",
      "name": "Log Query",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [3100, 560],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "content": "## Response Format\n\n**Success Response (200):**\n```json\n{\n  \"success\": true,\n  \"request_id\": \"req_...\",\n  \"query\": \"original query\",\n  \"matched_chunks\": [...],\n  \"result_count\": 10,\n  \"answer\": \"...\",\n  \"context_prompt\": \"...\"\n}\n```\n\n**Error Response (4xx):**\n```json\n{\n  \"success\": false,\n  \"error\": \"message\"\n}\n```",
        "height": 340,
        "width": 300
      },
      "id": "sticky-response",
      "name": "Sticky Note - Response",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [3100, 20]
    }
  ],
  "connections": {
    "Knowledge Gateway Webhook": {
      "main": [
        [
          {
            "node": "Validate Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Request": {
      "main": [
        [
          {
            "node": "Validation Error?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation Error?": {
      "main": [
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Embed Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embed Query": {
      "main": [
        [
          {
            "node": "Prepare Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Search": {
      "main": [
        [
          {
            "node": "Vector Similarity Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Similarity Search": {
      "main": [
        [
          {
            "node": "Process Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Results": {
      "main": [
        [
          {
            "node": "Generate Answer?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Answer?": {
      "main": [
        [
          {
            "node": "Build Context Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format without Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Context Prompt": {
      "main": [
        [
          {
            "node": "Generate Answer (Anthropic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Answer (Anthropic)": {
      "main": [
        [
          {
            "node": "Format with Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format with Answer": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format without Answer": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Responses": {
      "main": [
        [
          {
            "node": "Build Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Response": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          },
          {
            "node": "Log Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "tags": [
    {
      "name": "WiseBot",
      "id": "wisebot-tag"
    },
    {
      "name": "Gateway",
      "id": "gateway-tag"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1.0.0"
}
