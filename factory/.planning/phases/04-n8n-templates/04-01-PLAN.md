---
phase: 04-n8n-templates
plan: 01
type: execute
---

<objective>
Export live n8n bot workflows and create parameterized JSON templates for the chat orchestrator and tool webhook patterns.

Purpose: Enable new bot projects to import pre-built n8n workflow backends instead of building from scratch. These templates are the core backend infrastructure for every bot-track project.
Output: Two parameterized JSON templates in factory/n8n-templates/ — bot-chat-orchestrator.json and bot-tool-webhook.json
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@factory/README.md
@factory/.env.example
</context>

<safety>
READ-ONLY n8n access only. This plan uses ONLY `mcp__n8n__n8n_get_workflow` (GET) to export workflows.
- NEVER call n8n_update_*, n8n_create_*, n8n_delete_*, n8n_test_* tools
- All work produces local files in factory/n8n-templates/ — nothing is imported back to n8n
- Templates ship with "active": false to prevent webhook path collisions on import
- Real credential IDs are stripped and replaced with placeholders
</safety>

<tasks>

<task type="auto">
  <name>Task 1: Export and parameterize bot-chat-orchestrator.json</name>
  <files>factory/n8n-templates/bot-chat-orchestrator.json</files>
  <action>
  1. Use ToolSearch to load n8n MCP tools, then call mcp__n8n__n8n_get_workflow with ID "MY78EVsJL00xPMMw" (WaterBot Chat — the most complete chat orchestrator using the manual HTTP+pgvector pipeline).

  2. Save the raw JSON, then apply these parameterizations (all use {{PLACEHOLDER}} convention matching scaffold.sh):

  **Top-level fields:**
  - "name" → "{{BOT_NAME}} - Chat"
  - "active" → false (CRITICAL: prevents webhook hijacking on import)
  - Remove "id", "versionId", "meta", "pinData", "staticData" (n8n regenerates these on import)

  **Webhook node:**
  - parameters.path → "{{BOT_SLUG}}"
  - webhookId → "{{BOT_SLUG}}-chat-webhook"

  **Credential references (all nodes that have credentials):**
  - OpenAI credentials → { "id": "{{CREDENTIAL_OPENAI}}", "name": "OpenAi account" }
  - Anthropic credentials → { "id": "{{CREDENTIAL_ANTHROPIC}}", "name": "Anthropic account" }
  - Postgres credentials → { "id": "{{CREDENTIAL_POSTGRES}}", "name": "Postgres account" }

  **LLM model node:**
  - model → "{{LLM_MODEL}}" (default noted in README: claude-sonnet-4-20250514)
  - temperature → "{{LLM_TEMPERATURE}}" (default: 0.5)
  - maxTokensToSample → "{{LLM_MAX_TOKENS}}" (default: 800)

  **RAG pipeline nodes:**
  - HTTP embedding request URL stays as OpenAI endpoint (standard across all bots)
  - Embedding model stays as text-embedding-3-small with 1536 dimensions (factory standard)
  - In the Code node that builds the SQL query: replace table/function reference with "{{DB_SCHEMA}}.document_chunks"
  - Similarity threshold → "{{RAG_SIMILARITY_THRESHOLD}}" (default: 0.45)
  - Top-K limit → "{{RAG_TOP_K}}" (default: 6)

  **System prompt (in Build Prompt code node):**
  - Bot name references → "{{BOT_NAME}}"
  - Domain-specific key facts → "{{SYSTEM_PROMPT_FACTS}}"
  - User context field name → "{{USER_CONTEXT_FIELD}}" (e.g., waterContext, businessContext)
  - Context parsing logic → replace WaterBot-specific intake parsing with a generic "{{INTAKE_CONTEXT_BLOCK}}" placeholder
  - URL citation domain → "{{CITATION_DOMAIN}}"

  **Memory node (windowBufferMemory):**
  - contextWindowLength → "{{MEMORY_WINDOW}}" (default: 6)

  **Format Response code node:**
  - Source extraction can remain generic (pulls from RAG results)

  3. Validate the resulting JSON is syntactically valid with `node -e "JSON.parse(require('fs').readFileSync('factory/n8n-templates/bot-chat-orchestrator.json', 'utf8')); console.log('Valid JSON')"`.

  4. Preserve the escapeBraces() utility function and CORS headers exactly as-is (these are universal patterns, not bot-specific).

  AVOID: Do NOT use the Supabase VectorStore node pattern (only BizBot Pro uses it). Use the manual HTTP→Code→Postgres pipeline pattern — it's used in 8/9 production workflows and gives more control over similarity thresholds, category filters, and custom SQL.
  </action>
  <verify>
  - File exists at factory/n8n-templates/bot-chat-orchestrator.json
  - JSON is valid: `node -e "const j=JSON.parse(require('fs').readFileSync('factory/n8n-templates/bot-chat-orchestrator.json','utf8')); console.log('nodes:', j.nodes.length, 'connections:', Object.keys(j.connections).length)"`
  - No real credential IDs remain: grep for "NUfZfJJ5voQMfqAF", "Xtv78GML2gs5xqEj", "y814aU5gt5MUe3b8" should return nothing
  - No real webhook paths remain: grep for "/waterbot" should return nothing
  - Placeholders present: grep for "{{BOT_SLUG}}" and "{{DB_SCHEMA}}" should return matches
  - "active" is false
  </verify>
  <done>
  - bot-chat-orchestrator.json exists with valid JSON
  - Contains ~12 nodes (webhook, parse, embed, search, handle-empty, build-prompt, agent, format, respond + LLM/memory sub-nodes)
  - All hardcoded values replaced with {{PLACEHOLDER}} tokens
  - Zero real credentials, paths, or bot-specific content remain
  - "active": false
  </done>
</task>

<task type="auto">
  <name>Task 2: Export and parameterize bot-tool-webhook.json</name>
  <files>factory/n8n-templates/bot-tool-webhook.json</files>
  <action>
  1. Call mcp__n8n__n8n_get_workflow with ID "Y9Y56EyoomIFrQCN" (WaterBot Permits — a clean tool webhook with the standard RAG-no-memory pattern).

  2. Save the raw JSON, then apply the SAME parameterization approach as Task 1 with these differences:

  **Structural differences from chat orchestrator:**
  - NO memory node (tool webhooks are stateless single-shot RAG)
  - NO sessionId in the response envelope
  - System prompt is topic-focused, not conversational
  - Agent type should be kept as-is (no tools agent needed)

  **Webhook node:**
  - parameters.path → "{{BOT_SLUG}}-{{TOOL_SLUG}}" (e.g., "waterbot-permits" → pattern for tool-specific paths)
  - webhookId → "{{BOT_SLUG}}-{{TOOL_SLUG}}-webhook"

  **Credentials:** Same {{CREDENTIAL_*}} placeholders as Task 1.

  **RAG pipeline:** Same parameterization as Task 1, plus:
  - Category filter (if present in the SQL query) → "{{RAG_CATEGORY_FILTER}}" (e.g., 'permits', 'funding')
  - The tool webhook may pass a category to narrow vector search results

  **System prompt:**
  - Replace WaterBot permits-specific instructions with "{{TOOL_SYSTEM_PROMPT}}"
  - Keep the generic formatting rules (response length, citation format)

  **Response envelope:**
  - Tool webhooks return { response, sources, chunksUsed } (no sessionId)
  - Verify this pattern is preserved

  3. Validate JSON syntax same as Task 1.

  AVOID: Do NOT add memory nodes. Tool webhooks are intentionally stateless — each request is independent. This is a design decision, not an oversight.
  </action>
  <verify>
  - File exists at factory/n8n-templates/bot-tool-webhook.json
  - JSON is valid (same node -e check as Task 1)
  - No real credential IDs remain (same grep checks)
  - No real webhook paths: grep for "waterbot-permits" should return nothing
  - NO memory node present: grep for "windowBufferMemory" should return nothing
  - NO sessionId in Format Response code: grep for "sessionId" should return nothing (or only in a "not included" comment)
  - Placeholders present: grep for "{{TOOL_SLUG}}" and "{{RAG_CATEGORY_FILTER}}" should return matches
  - "active" is false
  </verify>
  <done>
  - bot-tool-webhook.json exists with valid JSON
  - Contains ~10 nodes (webhook, parse, embed, search, build-prompt, agent, format, respond + LLM sub-node)
  - No memory node — stateless design
  - All hardcoded values replaced with {{PLACEHOLDER}} tokens
  - Zero real credentials, paths, or bot-specific content remain
  - "active": false
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both JSON files exist in factory/n8n-templates/
- [ ] Both are syntactically valid JSON
- [ ] Zero real credential IDs in either file (grep for all 3 known IDs)
- [ ] Zero real webhook paths in either file
- [ ] Both have "active": false
- [ ] Chat orchestrator has memory node; tool webhook does NOT
- [ ] Both use the manual HTTP→Code→Postgres RAG pipeline (not Supabase VectorStore)
- [ ] {{PLACEHOLDER}} tokens are consistent between templates (same token names for same concepts)
</verification>

<success_criteria>

- 2 parameterized n8n workflow JSON templates created
- Templates follow the manual RAG pipeline pattern (8/9 production workflows use this)
- All bot-specific values replaced with {{PLACEHOLDER}} tokens
- Templates are safe: inactive, no real credentials, no webhook collisions
- JSON is valid and preserves n8n node/connection structure
</success_criteria>

<output>
After completion, create `.planning/phases/04-n8n-templates/04-01-SUMMARY.md` following the summary template.
</output>
