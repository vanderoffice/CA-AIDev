---
phase: 06-deploy-automation
plan: 01
type: execute
---

<objective>
Create standardized deploy scripts for both bot and form tracks plus a Supabase schema setup script.

Purpose: Automate the repetitive VPS deployment steps so every factory-produced project deploys the same way — no manual SSH commands to remember.
Output: Three executable bash scripts in factory/scripts/ (setup-supabase-schema.sh, deploy-bot.sh, deploy-form.sh)
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (dependency graph):
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/02-scaffolder/02-01-SUMMARY.md
@.planning/phases/05-bot-frontend/05-03-SUMMARY.md

# Key source files:
@factory/scripts/scaffold.sh
@factory/scripts/migrate-rag-tables.sql
@factory/README.md

**Tech stack available:** bash, ssh, rsync, docker, docker-compose, psql, pgvector
**Established patterns:**
- sed-based {{PLACEHOLDER}} substitution (from scaffold.sh)
- Schema-per-project with {schema}.document_chunks standard
- Bot track: rsync dist/ to VPS, nginx bind-mount serves it
- Form track: docker-compose.prod.yml on VPS with build args
- DB access: `ssh vps "docker exec -i supabase-db psql -U postgres -d postgres"`

**Constraining decisions:**
- [01-01]: .env.example uses Tailscale IP placeholder — deploy scripts should use VPS_HOST from .env
- [01-02]: All DB/API creds via env vars exclusively
- [01-02]: content_hash UNIQUE constraint for dedup in RAG tables
- [02-01]: sed-based template substitution with pipe delimiter
- [04-02]: 26 placeholders consolidated into single cross-template reference

**Deployment architecture (verified from existing projects):**
- **Bot track (vanderdev-website):** Local `npm run build` → `rsync -avz --delete dist/ VPS:/root/vanderdev-website/dist/`. Container `vanderdev-website` (nginx) bind-mounts dist/. No restart needed — just overwrite files.
- **Form track (ECOS pattern):** Code lives on VPS at `/root/Automation/{PROJECT}/`. Run `docker-compose -f docker-compose.prod.yml up --build -d`. Build args `VITE_SUPABASE_URL` + `VITE_SUPABASE_ANON_KEY` from VPS .env. Container joins `nginx-proxy` network. nginx-proxy labels set `VIRTUAL_HOST`, `VIRTUAL_PATH`, `VIRTUAL_DEST`.
- **Supabase schema:** `CREATE SCHEMA IF NOT EXISTS {name};` + `SET search_path TO {name}, public;` + `CREATE TABLE {name}.document_chunks(...)` with pgvector HNSW index. Executed via `docker exec -i supabase-db psql -U postgres -d postgres`.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create setup-supabase-schema.sh</name>
  <files>factory/scripts/setup-supabase-schema.sh</files>
  <action>
Create a bash script that sets up a new Supabase schema on the VPS for either track.

**Interface:**
```
setup-supabase-schema.sh --schema <name> --track <bot|form> [--host <vps-host>]
```

**Bot track behavior:**
1. CREATE SCHEMA IF NOT EXISTS {schema}
2. CREATE TABLE {schema}.document_chunks with all columns from migrate-rag-tables.sql pattern:
   - id SERIAL PRIMARY KEY
   - document_id TEXT, chunk_text TEXT, chunk_index INTEGER DEFAULT 0
   - file_name TEXT, file_path TEXT, category TEXT, subcategory TEXT, section_title TEXT
   - char_count INTEGER, content_hash TEXT
   - embedding vector(1536)
   - metadata JSONB, created_at TIMESTAMPTZ, updated_at TIMESTAMPTZ
3. CREATE HNSW index on embedding (vector_cosine_ops, m=16, ef_construction=64)
4. CREATE UNIQUE INDEX on content_hash WHERE content_hash IS NOT NULL
5. GRANT USAGE ON SCHEMA to anon, authenticated roles (Supabase PostgREST access)

**Form track behavior:**
1. CREATE SCHEMA IF NOT EXISTS {schema}
2. Print message: "Schema created. Add project-specific tables in {project}/sql/ and run them separately."
3. GRANT USAGE ON SCHEMA to anon, authenticated (same as bot)

**Execution:** Generate SQL dynamically (heredoc with variable interpolation), pipe to `ssh ${VPS_HOST} "docker exec -i supabase-db psql -U postgres -d postgres"`. Default VPS_HOST from $VPS_HOST env var or --host flag.

**Safety:** Use `set -euo pipefail`. Wrap SQL in BEGIN/COMMIT transaction. Check schema name matches `^[a-z][a-z0-9_]*$`. Add `--dry-run` flag that prints SQL without executing.

Follow scaffold.sh style: same flag parsing pattern, same error message format, same usage() function structure.
  </action>
  <verify>
    bash factory/scripts/setup-supabase-schema.sh --help prints usage.
    bash factory/scripts/setup-supabase-schema.sh --schema testbot --track bot --dry-run prints valid SQL with CREATE SCHEMA, CREATE TABLE, indexes, and GRANT statements.
    bash factory/scripts/setup-supabase-schema.sh --schema testform --track form --dry-run prints CREATE SCHEMA + GRANT but no document_chunks table.
    shellcheck factory/scripts/setup-supabase-schema.sh passes (or only style warnings).
  </verify>
  <done>Script is executable, --dry-run produces correct SQL for both tracks, flag validation rejects invalid schema names</done>
</task>

<task type="auto">
  <name>Task 2: Create deploy-bot.sh</name>
  <files>factory/scripts/deploy-bot.sh</files>
  <action>
Create a bash script that deploys a bot-track project (vanderdev-website SPA page) to VPS.

**Interface:**
```
deploy-bot.sh --name <slug> [--host <vps-host>] [--dry-run]
```

**Steps the script automates:**
1. Validate --name flag (same pattern as scaffold.sh)
2. Locate vanderdev-website directory: default `$HOME/Documents/GitHub/vanderdev-website` (override via `--website-dir`)
3. Verify the bot page exists: check `src/pages/${PascalName}.jsx` exists (derive PascalCase from slug: waterbot → WaterBot). If not found, error with guidance to create it.
4. Run `npm run build` in vanderdev-website directory
5. rsync dist/ to VPS: `rsync -avz --delete ${WEBSITE_DIR}/dist/ ${VPS_HOST}:/root/vanderdev-website/dist/`
6. Verify deployment: `ssh ${VPS_HOST} "curl -sf http://localhost/ | head -1"` returns HTML (nginx serves the SPA)
7. Print success: "Deployed. Bot available at https://vanderdev.net/{slug}"
8. Print reminder: "Ensure App.jsx has route for /{slug} and n8n webhooks are configured."

**Slug-to-PascalCase conversion:** Split on hyphens, capitalize first letter of each segment. water-bot → WaterBot. Use bash string manipulation (no external deps).

**--dry-run:** Print each command that would execute without running it.

**Error handling:** set -euo pipefail. Check npm is available. Check rsync is available. Check SSH connectivity before build (fail fast). Trap to print "Deploy failed at step: ..." on error.

Same flag parsing style as scaffold.sh.
  </action>
  <verify>
    bash factory/scripts/deploy-bot.sh --help prints usage.
    bash factory/scripts/deploy-bot.sh --name waterbot --dry-run prints the sequence: npm run build, rsync command, curl verification.
    shellcheck factory/scripts/deploy-bot.sh passes (or only style warnings).
  </verify>
  <done>Script is executable, --dry-run shows correct build+rsync+verify sequence, PascalCase conversion works for single-word and hyphenated names</done>
</task>

<task type="auto">
  <name>Task 3: Create deploy-form.sh</name>
  <files>factory/scripts/deploy-form.sh</files>
  <action>
Create a bash script that deploys a form-track project (Docker container) to VPS.

**Interface:**
```
deploy-form.sh --name <slug> --path-prefix <url-path> [--host <vps-host>] [--dry-run]
```

**Steps the script automates:**
1. Validate flags (--name required, --path-prefix required, e.g. "/ecosform")
2. Locate project source: default `$HOME/Documents/GitHub/Automation/${NAME}` (override via `--project-dir`)
3. Verify docker-compose.prod.yml exists in project dir. If not, error with guidance.
4. Sync project files to VPS: `rsync -avz --exclude node_modules --exclude .git --exclude dist ${PROJECT_DIR}/ ${VPS_HOST}:/root/Automation/${NAME}/`
5. SSH to VPS and run: `cd /root/Automation/${NAME} && docker-compose -f docker-compose.prod.yml up --build -d`
6. Wait 5 seconds, then verify container is running: `ssh ${VPS_HOST} "docker ps --filter name=${NAME} --format '{{.Status}}'"` shows "Up"
7. Verify HTTP response: `ssh ${VPS_HOST} "curl -sf http://localhost${PATH_PREFIX}/ | head -1"` (via nginx-proxy internal routing)
8. Print success: "Deployed. Form available at https://vanderdev.net${PATH_PREFIX}"

**--dry-run:** Print each command without executing.

**Error handling:** set -euo pipefail. Check SSH connectivity first. Check docker-compose.prod.yml exists before syncing. Trap for failure reporting.

**Important:** Do NOT hardcode Supabase URLs or anon keys in this script. Those are in the project's VPS .env file already (set during project setup). The script just triggers the build which reads them via docker-compose build args.

Same flag parsing style as scaffold.sh.
  </action>
  <verify>
    bash factory/scripts/deploy-form.sh --help prints usage.
    bash factory/scripts/deploy-form.sh --name ecos --path-prefix /ecosform --dry-run prints the sequence: rsync, docker-compose up --build, container health check, curl verification.
    shellcheck factory/scripts/deploy-form.sh passes (or only style warnings).
  </verify>
  <done>Script is executable, --dry-run shows correct rsync+docker-compose+verify sequence, path-prefix is used correctly in verification curl</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 3 scripts exist in factory/scripts/ and are executable (chmod +x)
- [ ] All 3 scripts pass --help, --dry-run for both tracks where applicable
- [ ] shellcheck passes on all 3 scripts (warnings OK, errors not)
- [ ] Flag parsing follows scaffold.sh conventions (same error format, same usage pattern)
- [ ] No hardcoded credentials in any script — all via env vars or flags
</verification>

<success_criteria>

- Three deploy scripts created: setup-supabase-schema.sh, deploy-bot.sh, deploy-form.sh
- All scripts have --dry-run mode for safe verification
- All scripts follow scaffold.sh conventions (flag parsing, error handling, usage)
- No secrets hardcoded — everything via env vars
- Scripts are independently usable (don't require each other)
</success_criteria>

<output>
After completion, create `.planning/phases/06-deploy-automation/06-01-SUMMARY.md`
</output>
