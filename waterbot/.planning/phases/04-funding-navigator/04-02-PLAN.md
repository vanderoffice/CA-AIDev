---
phase: 04-funding-navigator
plan: 02
type: execute
---

<objective>
Create the deterministic matching algorithm that scores user answers against the 58-program funding catalog and integrate it into FundingNavigator.

Purpose: Core business logic — filter and rank programs by eligibility, giving users a prioritized list with clear tier labels.
Output: matchFundingPrograms() utility function + FundingNavigator calling it on questionnaire submission.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries:
@.planning/phases/03-funding-data-model/03-01-SUMMARY.md
@.planning/phases/03-funding-data-model/03-02-SUMMARY.md
@.planning/phases/04-funding-navigator/04-01-SUMMARY.md

# Key source files:
@src/components/FundingNavigator.jsx
@public/funding-programs.json

**Tech stack available:** React 18 + Vite + Tailwind
**Established patterns:**
- Flat array filter matching (not tree-based)
- Typed eligibility predicates per program
- Three-value dacRequired (false/true/"preferred")
- 13 canonical tags for matching

**Constraining decisions:**
- [03-01]: Flat array because funding matching is filter-based, not path-based
- [03-01]: Three-value dacRequired (false/true/"preferred")
- [03-02]: All 58 programs have canonical tags for matching consistency
- [PROJECT]: Deterministic matching — more trustworthy than LLM for eligibility decisions

**Eligibility schema fields used for matching:**
- `eligibility.entityTypes[]` — must include user's entity type
- `eligibility.projectTypes[]` — must overlap with user's selected project types
- `eligibility.populationMax` — user's population must be under this limit (null = no limit)
- `eligibility.systemSizeMax` — secondary size check (null = no limit)
- `eligibility.dacRequired` — false (anyone), true (DAC only), "preferred" (DAC gets bonus)
- `eligibility.matchRequired` — boolean
- `eligibility.matchPercentage` — number (25, 50, etc.)

**User answers shape (from Plan 04-01):**
```
{
  entityType: 'public-agency' | 'tribe' | 'nonprofit' | 'private-utility' | 'mutual-water-company',
  projectTypes: ['treatment', 'distribution', ...],
  populationServed: 'under-500' | '500-3300' | '3300-10000' | '10000-50000' | 'over-50000',
  dacStatus: 'dac' | 'sdac' | 'no' | 'unsure',
  matchFunds: 'yes' | 'limited' | 'no'
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create matchFundingPrograms utility function</name>
  <files>src/utils/matchFundingPrograms.js</files>
  <action>
Create a pure function that takes user answers + programs array and returns ranked results with tier assignments.

**Function signature:**
```
export default function matchFundingPrograms(answers, programs) → { eligible: [], likelyEligible: [], mayQualify: [] }
```

**Population range → number mapping (for comparisons):**
```
const POPULATION_MAP = {
  'under-500': 250,
  '500-3300': 1900,
  '3300-10000': 6500,
  '10000-50000': 30000,
  'over-50000': 75000
}
```
Use midpoint values for comparison against `populationMax`. The comparison is: if program has populationMax AND user's midpoint exceeds it, that's a population mismatch.

**Matching logic per program (iterate all 58):**

1. **Entity type check:**
   - If program's `entityTypes` array does NOT include user's `entityType` → skip entirely (hard filter)

2. **Project type check:**
   - If program's `projectTypes` array has NO overlap with user's `projectTypes` → skip entirely (hard filter)
   - Track overlap count for scoring (more overlap = better fit)

3. **Population check:**
   - If program's `populationMax` is not null AND user's population midpoint > populationMax → skip (hard filter)

4. **DAC check:**
   - If program's `dacRequired` is `true` AND user's dacStatus is `'no'` → skip (hard filter)
   - If program's `dacRequired` is `true` AND user's dacStatus is `'unsure'` → don't skip, but flag as uncertain

5. **Match funds check:**
   - If program's `matchRequired` is `true` AND user's matchFunds is `'no'` → don't hard skip, but flag as barrier

**Tier assignment (for programs that pass hard filters):**

- **Eligible:** All checks pass cleanly. Entity matches, project type overlaps, population within limits, DAC satisfied (or not required), match funds OK (or not required).

- **Likely Eligible:** Most checks pass but with uncertainty:
  - DAC is "preferred" and user is DAC/SDAC (bonus but not required — still Eligible actually)
  - DAC is required but user said "unsure"
  - Match is required but user said "limited"
  - Program's dacRequired is "preferred" and user is NOT DAC (still eligible, just won't get preference)

- **May Qualify:** Program passed hard filters but has barriers:
  - Match required but user said "no" (financial barrier)
  - Only 1 project type overlap out of many user types (weak fit)
  - Program has `additionalCriteria` that suggest further qualification steps

**Scoring within tiers (for sort order):**
Within each tier, sort by:
1. Project type overlap count (descending — more matching types = more relevant)
2. Funding type preference: grants first, then loan-and-grant, then loans (users generally prefer free money)
3. Alphabetical by name (stable tiebreaker)

**Return format:**
Each matched program in the result arrays should be the original program object spread with additional fields:
```
{
  ...program,
  tier: 'eligible' | 'likely-eligible' | 'may-qualify',
  matchScore: number,
  matchReasons: string[],   // e.g. ["Matches: treatment, distribution", "DAC preference applies"]
  barriers: string[]         // e.g. ["Requires 25% matching funds"]
}
```

**What to avoid:** Do NOT use fuzzy matching, ML, or anything non-deterministic. Pure filter + sort. Do NOT import React — this is a pure utility function. Do NOT hard-code program IDs — work only with the eligibility schema fields so it works with any programs array.
  </action>
  <verify>Import function in Node and test with sample answers: `node -e "import('./src/utils/matchFundingPrograms.js').then(m => { const programs = require('./public/funding-programs.json').programs; console.log(Object.keys(m.default({entityType:'public-agency',projectTypes:['treatment'],populationServed:'under-500',dacStatus:'dac',matchFunds:'yes'}, programs)).map(k => k + ': ' + m.default({entityType:'public-agency',projectTypes:['treatment'],populationServed:'under-500',dacStatus:'dac',matchFunds:'yes'}, programs)[k].length)) })"` — should return counts for all three tiers.</verify>
  <done>matchFundingPrograms function correctly filters 58 programs, assigns tiers, sorts within tiers, and returns categorized results with matchReasons and barriers.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate matching into FundingNavigator</name>
  <files>src/components/FundingNavigator.jsx</files>
  <action>
Wire the matching algorithm into FundingNavigator so it runs on questionnaire completion:

1. Import funding data: `import fundingData from '../../public/funding-programs.json'`
   Import matcher: `import matchFundingPrograms from '../utils/matchFundingPrograms'`

2. When user completes the final step (step 4 — matching funds question), run:
   ```
   const results = matchFundingPrograms(answers, fundingData.programs)
   setMatchedPrograms(results)
   setShowResults(true)
   ```

3. For single-select steps (0, 2, 3, 4): on option click, update the answer AND if it's the last step, run matching and show results. For non-last single-select steps, auto-advance to next step.

4. For the multi-select step (step 1 — project types): the "Next" button (from WizardStepper's onNext) should advance. On the LAST step, the button should say "Find Programs" instead of "Next" or "Finish".

5. Update the placeholder results view to show a summary count while Plan 04-03 builds the full results UI:
   ```
   <div>
     <h3>Programs Found</h3>
     <p>{matchedPrograms.eligible.length} Eligible</p>
     <p>{matchedPrograms.likelyEligible.length} Likely Eligible</p>
     <p>{matchedPrograms.mayQualify.length} May Qualify</p>
     <button onClick={restart}>Search Again</button>
   </div>
   ```
   Style this summary consistent with the existing dark theme.

6. Update `onRestart` to also clear `matchedPrograms` and set `showResults = false`.

**What to avoid:** Do NOT build the full results UI with ResultCards yet — that's Plan 04-03. Just show counts as a summary. Do NOT change the questionnaire step content or answers shape from Plan 04-01.
  </action>
  <verify>`npm run build` succeeds. Navigate through all 5 questions → results summary shows program counts by tier. Restart clears everything.</verify>
  <done>Matching algorithm runs on questionnaire completion. Results summary shows correct counts for Eligible / Likely Eligible / May Qualify tiers. Restart works.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] matchFundingPrograms.js exists and exports a function
- [ ] Small DAC public agency with treatment project → sees many Eligible programs
- [ ] Large private utility → sees fewer programs (correctly filtered)
- [ ] Programs sorted by project type overlap and funding type within tiers
- [ ] Results summary displays after completing questionnaire
- [ ] Restart clears results and returns to step 1
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No build errors introduced
- Matching algorithm is deterministic and filter-based (no ML/fuzzy logic)
- All 58 programs evaluated against user answers
- Three tiers correctly assigned with reasons and barriers
</success_criteria>

<output>
After completion, create `.planning/phases/04-funding-navigator/04-02-SUMMARY.md`
</output>
